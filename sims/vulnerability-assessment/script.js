// Vulnerability Assessment Flow - p5.js MicroSim
// Interactive vertical flowchart for organizational vulnerability assessment

let canvasWidth = 900;
const canvasHeight = 500;

const INDIGO = [48, 63, 159];
const INDIGO_LIGHT = [92, 107, 192];
const AMBER = [212, 136, 15];
const GOLD = [255, 215, 0];
const CHAMPAGNE = [255, 248, 231];
const DARK_GRAY = [80, 80, 80];
const WHITE = [255, 255, 255];

// Flow elements: each has type, label, position, and info
// Types: 'process', 'decision', 'action', 'output'
// Positions are computed in layoutElements()

const flowElements = [
    {
        id: 0,
        type: 'process',
        label: 'Run Articulation\nPoint Analysis',
        info: 'Cypher Query:\nCALL gds.articulationPoints.stream(\'orgGraph\')\nYIELD nodeId\nRETURN gds.util.asNode(nodeId).name AS spof\n\nFinds nodes whose removal disconnects the graph -- these are your single points of failure.',
        mainFlow: true
    },
    {
        id: 1,
        type: 'decision',
        label: 'Any SPOFs\nfound?',
        info: 'Decision Point:\nIf the articulation point algorithm returns any nodes, those people are structural vulnerabilities. Their departure would sever communication paths between teams.',
        mainFlow: true,
        yesBranch: 2,
        noBranch: null // continues down
    },
    {
        id: 2,
        type: 'action',
        label: 'Classify by depts\naffected',
        info: 'Cypher Query:\nMATCH (spof:Person)-[:WORKS_IN]->(d:Department)\nWHERE spof.name IN $spofList\nRETURN d.name, collect(spof.name), count(*)\nORDER BY count(*) DESC\n\nGroups SPOFs by department to prioritize mitigation efforts.',
        mainFlow: false
    },
    {
        id: 3,
        type: 'action',
        label: 'Generate\nSPOF Report',
        info: 'Output:\nA ranked report listing each SPOF with:\n- Departments affected if they leave\n- Number of disconnected subgraphs created\n- Recommended mitigation (cross-training, backup contacts)\n- Risk severity score (High / Medium / Low)',
        mainFlow: false
    },
    {
        id: 4,
        type: 'process',
        label: 'Run Knowledge\nConcentration Analysis',
        info: 'Cypher Query:\nMATCH (p:Person)-[:HAS_SKILL]->(s:Skill)\nWITH s, collect(p) AS holders\nWHERE size(holders) < 3\nRETURN s.name, size(holders),\n       [h IN holders | h.name]\n\nIdentifies skills held by fewer than 3 people -- dangerously concentrated knowledge.',
        mainFlow: true
    },
    {
        id: 5,
        type: 'decision',
        label: 'Skills held by\n< 3 people?',
        info: 'Decision Point:\nThe threshold of 3 is configurable but represents the minimum for organizational resilience. With fewer than 3 holders, a single departure plus one illness could leave the org with zero coverage.',
        mainFlow: true,
        yesBranch: 6,
        noBranch: null
    },
    {
        id: 6,
        type: 'action',
        label: 'Flag for knowledge\ntransfer program',
        info: 'Action:\nMATCH (expert:Person)-[:HAS_SKILL]->(s:Skill)\nWHERE s.name IN $criticalSkills\nMATCH (candidate:Person)-[:WORKS_IN]->(d:Department)\nWHERE NOT (candidate)-[:HAS_SKILL]->(s)\nRETURN s.name, expert.name, candidate.name\n\nPairs skill holders with potential learners in related departments.',
        mainFlow: false
    },
    {
        id: 7,
        type: 'process',
        label: 'Run Succession\nGap Analysis',
        info: 'Cypher Query:\nMATCH (leader:Person)-[:HOLDS]->(r:Role)\nWHERE r.level >= \'Director\'\nOPTIONAL MATCH (leader)<-[:MENTORED_BY]-(successor:Person)\nWHERE successor.readiness >= 0.7\nRETURN leader.name, r.title,\n       collect(successor.name) AS pipeline\n\nIdentifies leadership roles with no viable internal successors.',
        mainFlow: true
    },
    {
        id: 8,
        type: 'decision',
        label: 'Leaders without\nviable successors?',
        info: 'Decision Point:\nA "viable successor" has a readiness score >= 0.7, meaning they have at least 70% of the required competencies. Roles with zero viable successors represent critical succession gaps.',
        mainFlow: true,
        yesBranch: 9,
        noBranch: null
    },
    {
        id: 9,
        type: 'action',
        label: 'Initiate leadership\npipeline development',
        info: 'Action:\nMATCH (leader:Person)-[:HOLDS]->(r:Role)\nWHERE NOT EXISTS {\n  MATCH (leader)<-[:MENTORED_BY]-(s)\n  WHERE s.readiness >= 0.7\n}\nMATCH (candidate:Person)\nWHERE candidate.potential = \'High\'\nRETURN r.title, leader.name,\n       collect(candidate.name) AS hipos\n\nMatches high-potential employees to ungapped leadership roles for development.',
        mainFlow: false
    },
    {
        id: 10,
        type: 'output',
        label: 'Generate Organizational\nResilience Score',
        info: 'Algorithm:\nResilience = w1*(1 - spofRatio) + w2*(1 - knowledgeRisk) + w3*(1 - successionGap)\n\nDefault weights: w1=0.4, w2=0.35, w3=0.25\n\nScore range: 0.0 (critical) to 1.0 (resilient)\nThresholds: < 0.4 Critical | 0.4-0.7 At Risk | > 0.7 Healthy',
        mainFlow: true
    }
];

// Layout positions computed dynamically
let positions = [];
let stepBtn = {};
let resetBtn = {};
let activeStep = -1; // -1 means no step active
let selectedElement = -1; // clicked element for info
let infoPanelVisible = false;

function updateCanvasSize() {
    let container = document.getElementById('canvas-container');
    if (container) canvasWidth = container.offsetWidth;
}

function setup() {
    updateCanvasSize();
    let canvas = createCanvas(canvasWidth, canvasHeight);
    canvas.parent('canvas-container');
    textFont('Arial');
    layoutElements();
}

function layoutElements() {
    positions = [];

    // Main flow column center X
    let mainX = canvasWidth * 0.38;
    // Action/branch column X (to the right)
    let branchX = canvasWidth * 0.72;

    // Vertical spacing for main flow
    let startY = 52;
    let mainSpacing = 56;

    // Button positions
    stepBtn = { x: canvasWidth / 2 - 105, y: 8, w: 100, h: 28 };
    resetBtn = { x: canvasWidth / 2 + 5, y: 8, w: 80, h: 28 };

    // Element dimensions
    let processW = 190;
    let processH = 38;
    let decisionW = 150;
    let decisionH = 48;
    let actionW = 175;
    let actionH = 36;
    let outputW = 220;
    let outputH = 40;

    // Main flow elements with their Y positions
    // IDs: 0(proc), 1(dec), 4(proc), 5(dec), 7(proc), 8(dec), 10(output)
    let mainFlowIds = [0, 1, 4, 5, 7, 8, 10];
    let mainY = startY;

    for (let i = 0; i < mainFlowIds.length; i++) {
        let id = mainFlowIds[i];
        let el = flowElements[id];
        let w, h;
        if (el.type === 'process') { w = processW; h = processH; }
        else if (el.type === 'decision') { w = decisionW; h = decisionH; }
        else if (el.type === 'output') { w = outputW; h = outputH; }
        else { w = actionW; h = actionH; }

        positions[id] = { x: mainX, y: mainY, w: w, h: h };
        mainY += mainSpacing;
    }

    // Action elements positioned to the right of their decision
    // id 2 & 3 branch from decision 1
    let dec1 = positions[1];
    positions[2] = { x: branchX, y: dec1.y - 10, w: actionW, h: actionH };
    positions[3] = { x: branchX, y: dec1.y + 28, w: actionW, h: actionH };

    // id 6 branches from decision 5
    let dec5 = positions[5];
    positions[6] = { x: branchX, y: dec5.y + 5, w: actionW, h: actionH };

    // id 9 branches from decision 8
    let dec8 = positions[8];
    positions[9] = { x: branchX, y: dec8.y + 5, w: actionW, h: actionH };
}

function draw() {
    background(245);

    // Title
    fill(30);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(15);
    textStyle(BOLD);
    text('Vulnerability Assessment Flow', canvasWidth / 2, stepBtn.y + stepBtn.h + 14);
    textStyle(NORMAL);

    // Draw buttons
    drawButton(stepBtn, 'Step Through', INDIGO, INDIGO_LIGHT);
    drawButton(resetBtn, 'Reset', DARK_GRAY, [120, 120, 120]);

    // Progress indicator
    drawProgress();

    // Draw arrows first (behind elements)
    drawAllArrows();

    // Draw all flowchart elements
    for (let i = 0; i < flowElements.length; i++) {
        drawFlowElement(i);
    }

    // Draw info panel if visible
    if (infoPanelVisible && selectedElement >= 0) {
        drawInfoPanel(selectedElement);
    }
}

function drawButton(btn, label, col, hoverCol) {
    let isHover = mouseX > btn.x && mouseX < btn.x + btn.w &&
                  mouseY > btn.y && mouseY < btn.y + btn.h;
    fill(isHover ? hoverCol : col);
    stroke(30);
    strokeWeight(1);
    rect(btn.x, btn.y, btn.w, btn.h, 6);
    fill(255);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(12);
    text(label, btn.x + btn.w / 2, btn.y + btn.h / 2);
}

function drawProgress() {
    let order = getStepOrder();
    let totalSteps = order.length;
    let dotSize = 6;
    let dotSpacing = 14;
    let totalWidth = totalSteps * dotSpacing;
    let startX = canvasWidth / 2 - totalWidth / 2;
    let py = stepBtn.y + stepBtn.h + 32;
    let activeIdx = activeStep >= 0 ? order.indexOf(activeStep) : -1;

    for (let i = 0; i < totalSteps; i++) {
        let isActive = (i === activeIdx);
        let isPast = (activeIdx >= 0 && i < activeIdx);

        if (isActive) {
            fill(...GOLD);
            stroke(...AMBER);
            strokeWeight(1.5);
        } else if (isPast) {
            fill(...AMBER);
            noStroke();
        } else {
            fill(200);
            noStroke();
        }
        ellipse(startX + i * dotSpacing + dotSpacing / 2, py, isActive ? dotSize + 3 : dotSize);
    }
}

function drawAllArrows() {
    let arrowCol = [100, 100, 100];
    let activeArrowCol = AMBER;

    // Main flow vertical arrows: 0->1, 1->4(no), 4->5, 5->7(no), 7->8, 8->10(no)
    let mainConnections = [
        [0, 1], [1, 4], [4, 5], [5, 7], [7, 8], [8, 10]
    ];
    for (let conn of mainConnections) {
        let from = positions[conn[0]];
        let to = positions[conn[1]];
        let isActive = isConnectionActive(conn[0], conn[1]);
        let col = isActive ? activeArrowCol : arrowCol;
        let weight = isActive ? 2.5 : 1.5;

        let fromY = from.y + from.h;
        let toY = to.y;

        drawArrowLine(from.x, fromY, to.x, toY, col, weight);

        // "No" labels on decision->next process connections
        if (flowElements[conn[0]].type === 'decision') {
            let midY = (fromY + toY) / 2;
            fill(100);
            noStroke();
            textAlign(LEFT, CENTER);
            textSize(10);
            textStyle(ITALIC);
            text('No', from.x + 8, midY);
            textStyle(NORMAL);
        }
    }

    // Yes branches: decision -> action boxes
    let yesBranches = [
        [1, 2],  // decision 1 -> classify
        [2, 3],  // classify -> report
        [5, 6],  // decision 5 -> flag
        [8, 9]   // decision 8 -> initiate
    ];
    for (let conn of yesBranches) {
        let from = positions[conn[0]];
        let to = positions[conn[1]];
        let isActive = isConnectionActive(conn[0], conn[1]);
        let col = isActive ? activeArrowCol : arrowCol;
        let weight = isActive ? 2.5 : 1.5;

        if (conn[0] === 2) {
            // vertical arrow from classify to report (both on right side)
            drawArrowLine(from.x, from.y + from.h, to.x, to.y, col, weight);
        } else {
            // horizontal arrow from decision to action
            let fromX = from.x + from.w / 2;
            let fromY = from.y + from.h / 2;
            let toX = to.x - to.w / 2;
            let toY = to.y + to.h / 2;

            drawHorizontalArrow(fromX, fromY, toX, toY, col, weight);

            // "Yes" label
            fill(100);
            noStroke();
            textAlign(CENTER, CENTER);
            textSize(10);
            textStyle(ITALIC);
            text('Yes', (fromX + toX) / 2, fromY - 10);
            textStyle(NORMAL);
        }
    }

    // Return arrows from action boxes back to main flow
    // SPOF Report (3) returns to process 4
    drawReturnArrow(3, 4);
    // Knowledge flag (6) returns to process 7
    drawReturnArrow(6, 7);
    // Leadership pipeline (9) returns to output 10
    drawReturnArrow(9, 10);
}

function drawReturnArrow(fromId, toId) {
    let from = positions[fromId];
    let to = positions[toId];
    let isActive = isConnectionActive(fromId, toId);
    let col = isActive ? AMBER : [160, 160, 160];
    let weight = isActive ? 2 : 1;

    let startX = from.x;
    let startY = from.y + from.h;
    let endX = to.x + to.w / 2 - 10;
    let endY = to.y + to.h / 2;

    // Curve down and left
    stroke(...col);
    strokeWeight(weight);
    noFill();
    let midY = startY + 12;

    beginShape();
    vertex(startX, startY);
    vertex(startX, midY);
    vertex(endX + 10, midY);
    vertex(endX + 10, endY);
    endShape();

    // Small arrowhead pointing left
    fill(...col);
    noStroke();
    let sz = 6;
    triangle(endX + 10 - sz, endY, endX + 10 + 2, endY - sz / 2, endX + 10 + 2, endY + sz / 2);
}

function isConnectionActive(fromId, toId) {
    if (activeStep < 0) return false;
    // Build step order
    let order = getStepOrder();
    let fromIdx = order.indexOf(fromId);
    let toIdx = order.indexOf(toId);
    if (fromIdx < 0 || toIdx < 0) return false;
    // Active if both are before or at the active step index
    let activeIdx = order.indexOf(activeStep);
    return fromIdx <= activeIdx && toIdx <= activeIdx;
}

function getStepOrder() {
    // The order we step through: main flow with yes branches inline
    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
}

function drawArrowLine(x1, y1, x2, y2, col, weight) {
    stroke(...col);
    strokeWeight(weight);
    line(x1, y1, x2, y2);

    // Arrowhead
    let angle = atan2(y2 - y1, x2 - x1);
    let sz = 8;
    fill(...col);
    noStroke();
    triangle(
        x2, y2,
        x2 - sz * cos(angle - PI / 6), y2 - sz * sin(angle - PI / 6),
        x2 - sz * cos(angle + PI / 6), y2 - sz * sin(angle + PI / 6)
    );
}

function drawHorizontalArrow(x1, y1, x2, y2, col, weight) {
    stroke(...col);
    strokeWeight(weight);
    line(x1, y1, x2, y2);

    let angle = atan2(y2 - y1, x2 - x1);
    let sz = 8;
    fill(...col);
    noStroke();
    triangle(
        x2, y2,
        x2 - sz * cos(angle - PI / 6), y2 - sz * sin(angle - PI / 6),
        x2 - sz * cos(angle + PI / 6), y2 - sz * sin(angle + PI / 6)
    );
}

function drawFlowElement(idx) {
    let el = flowElements[idx];
    let pos = positions[idx];
    if (!pos) return;

    let x = pos.x;
    let y = pos.y;
    let w = pos.w;
    let h = pos.h;

    let isActive = (idx === activeStep);
    let isPast = activeStep >= 0 && getStepOrder().indexOf(idx) < getStepOrder().indexOf(activeStep);
    let isSelected = (idx === selectedElement && infoPanelVisible);
    let isHover = isMouseOver(idx);

    // Glow effect for active step
    if (isActive) {
        noFill();
        stroke(...GOLD, 100);
        strokeWeight(6);
        if (el.type === 'decision') {
            drawDiamond(x, y, w, h);
        } else {
            rect(x - w / 2, y, w, h, el.type === 'output' ? 12 : 8);
        }
    }

    if (el.type === 'process') {
        drawProcessBox(x, y, w, h, el.label, isActive, isPast, isHover, isSelected);
    } else if (el.type === 'decision') {
        drawDecisionDiamond(x, y, w, h, el.label, isActive, isPast, isHover, isSelected);
    } else if (el.type === 'action') {
        drawActionBox(x, y, w, h, el.label, isActive, isPast, isHover, isSelected);
    } else if (el.type === 'output') {
        drawOutputBox(x, y, w, h, el.label, isActive, isPast, isHover, isSelected);
    }
}

function drawProcessBox(cx, y, w, h, label, isActive, isPast, isHover, isSelected) {
    let x = cx - w / 2;

    // Shadow
    noStroke();
    fill(0, 0, 0, 20);
    rect(x + 2, y + 2, w, h, 8);

    // Box
    if (isActive) {
        fill(...INDIGO);
        stroke(...GOLD);
        strokeWeight(3);
    } else if (isPast) {
        fill(92, 107, 192);
        stroke(...AMBER);
        strokeWeight(1.5);
    } else if (isHover) {
        fill(72, 87, 179);
        stroke(30, 30, 60);
        strokeWeight(1.5);
    } else {
        fill(...INDIGO);
        stroke(30, 30, 60);
        strokeWeight(1.5);
    }
    rect(x, y, w, h, 8);

    // Label
    fill(255);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(11);
    let lines = label.split('\n');
    for (let i = 0; i < lines.length; i++) {
        let yOff = (i - (lines.length - 1) / 2) * 14;
        text(lines[i], cx, y + h / 2 + yOff);
    }
}

function drawDecisionDiamond(cx, y, w, h, label, isActive, isPast, isHover, isSelected) {
    // Shadow
    noStroke();
    fill(0, 0, 0, 20);
    push();
    translate(2, 2);
    drawDiamond(cx, y, w, h);
    pop();

    // Diamond
    if (isActive) {
        fill(...AMBER);
        stroke(...GOLD);
        strokeWeight(3);
    } else if (isPast) {
        fill(230, 165, 50);
        stroke(...AMBER);
        strokeWeight(1.5);
    } else if (isHover) {
        fill(230, 155, 30);
        stroke(30);
        strokeWeight(1.5);
    } else {
        fill(...AMBER);
        stroke(160, 100, 10);
        strokeWeight(1.5);
    }
    drawDiamond(cx, y, w, h);

    // Label
    fill(255);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(10);
    let lines = label.split('\n');
    for (let i = 0; i < lines.length; i++) {
        let yOff = (i - (lines.length - 1) / 2) * 13;
        text(lines[i], cx, y + h / 2 + yOff);
    }
}

function drawDiamond(cx, y, w, h) {
    let midX = cx;
    let midY = y + h / 2;
    beginShape();
    vertex(midX, y);
    vertex(midX + w / 2, midY);
    vertex(midX, y + h);
    vertex(midX - w / 2, midY);
    endShape(CLOSE);
}

function drawActionBox(cx, y, w, h, label, isActive, isPast, isHover, isSelected) {
    let x = cx - w / 2;

    // Shadow
    noStroke();
    fill(0, 0, 0, 15);
    rect(x + 2, y + 2, w, h, 6);

    // Box
    if (isActive) {
        fill(230, 240, 255);
        stroke(...INDIGO);
        strokeWeight(2.5);
    } else if (isPast) {
        fill(220, 230, 250);
        stroke(92, 107, 192);
        strokeWeight(1.5);
    } else if (isHover) {
        fill(215, 225, 245);
        stroke(...INDIGO);
        strokeWeight(1.5);
    } else {
        fill(230, 235, 250);
        stroke(150, 160, 190);
        strokeWeight(1);
    }
    rect(x, y, w, h, 6);

    // Label
    fill(40, 50, 100);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(10);
    let lines = label.split('\n');
    for (let i = 0; i < lines.length; i++) {
        let yOff = (i - (lines.length - 1) / 2) * 13;
        text(lines[i], cx, y + h / 2 + yOff);
    }
}

function drawOutputBox(cx, y, w, h, label, isActive, isPast, isHover, isSelected) {
    let x = cx - w / 2;

    // Shadow
    noStroke();
    fill(0, 0, 0, 20);
    rect(x + 2, y + 2, w, h, 12);

    // Box
    if (isActive) {
        fill(...GOLD);
        stroke(...AMBER);
        strokeWeight(3);
    } else if (isHover) {
        fill(255, 225, 30);
        stroke(...AMBER);
        strokeWeight(2);
    } else {
        fill(...GOLD);
        stroke(200, 170, 10);
        strokeWeight(1.5);
    }
    rect(x, y, w, h, 12);

    // Label
    fill(40);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(11);
    textStyle(BOLD);
    let lines = label.split('\n');
    for (let i = 0; i < lines.length; i++) {
        let yOff = (i - (lines.length - 1) / 2) * 14;
        text(lines[i], cx, y + h / 2 + yOff);
    }
    textStyle(NORMAL);
}

function drawInfoPanel(idx) {
    let el = flowElements[idx];
    let infoText = el.info;

    // Panel on the far left or bottom depending on space
    let panelW = min(280, canvasWidth * 0.32);
    let panelH = 200;
    let panelX = 8;
    let panelY = canvasHeight - panelH - 8;

    // If the element is on the left side, put panel further left bottom
    let pos = positions[idx];

    // Panel background
    fill(255, 252, 240);
    stroke(...AMBER);
    strokeWeight(2);
    rect(panelX, panelY, panelW, panelH, 10);

    // Header
    fill(...INDIGO);
    noStroke();
    textAlign(LEFT, TOP);
    textSize(11);
    textStyle(BOLD);

    let headerLabel = el.label.replace('\n', ' ');
    text(headerLabel, panelX + 10, panelY + 10);
    textStyle(NORMAL);

    // Divider
    stroke(200);
    strokeWeight(1);
    line(panelX + 10, panelY + 28, panelX + panelW - 10, panelY + 28);

    // Info text with word wrap
    fill(50);
    noStroke();
    textSize(10);
    textAlign(LEFT, TOP);

    let lines = wrapText(infoText, panelW - 24, 10);
    for (let i = 0; i < lines.length; i++) {
        let ty = panelY + 34 + i * 13;
        if (ty + 13 > panelY + panelH - 5) break;
        text(lines[i], panelX + 12, ty);
    }

    // Close hint
    fill(150);
    textAlign(RIGHT, BOTTOM);
    textSize(9);
    text('Click again to close', panelX + panelW - 8, panelY + panelH - 5);
}

function wrapText(txt, maxWidth, fontSize) {
    textSize(fontSize);
    let result = [];
    let paragraphs = txt.split('\n');
    for (let para of paragraphs) {
        if (para.trim() === '') {
            result.push('');
            continue;
        }
        let words = para.split(' ');
        let currentLine = '';
        for (let w of words) {
            let testLine = currentLine.length === 0 ? w : currentLine + ' ' + w;
            if (textWidth(testLine) > maxWidth) {
                if (currentLine.length > 0) result.push(currentLine);
                currentLine = w;
            } else {
                currentLine = testLine;
            }
        }
        if (currentLine.length > 0) result.push(currentLine);
    }
    return result;
}

function isMouseOver(idx) {
    let pos = positions[idx];
    if (!pos) return false;
    let el = flowElements[idx];

    if (el.type === 'decision') {
        // Diamond hit test
        let cx = pos.x;
        let cy = pos.y + pos.h / 2;
        let hw = pos.w / 2;
        let hh = pos.h / 2;
        let dx = abs(mouseX - cx) / hw;
        let dy = abs(mouseY - cy) / hh;
        return (dx + dy) <= 1;
    } else {
        let x = pos.x - pos.w / 2;
        return mouseX >= x && mouseX <= x + pos.w &&
               mouseY >= pos.y && mouseY <= pos.y + pos.h;
    }
}

function mousePressed() {
    // Step Through button
    if (mouseX > stepBtn.x && mouseX < stepBtn.x + stepBtn.w &&
        mouseY > stepBtn.y && mouseY < stepBtn.y + stepBtn.h) {
        stepForward();
        return;
    }

    // Reset button
    if (mouseX > resetBtn.x && mouseX < resetBtn.x + resetBtn.w &&
        mouseY > resetBtn.y && mouseY < resetBtn.y + resetBtn.h) {
        resetAll();
        return;
    }

    // Check element clicks
    for (let i = 0; i < flowElements.length; i++) {
        if (isMouseOver(i)) {
            if (selectedElement === i && infoPanelVisible) {
                infoPanelVisible = false;
                selectedElement = -1;
            } else {
                selectedElement = i;
                infoPanelVisible = true;
            }
            return;
        }
    }

    // Click outside -- close info panel
    infoPanelVisible = false;
    selectedElement = -1;
}

function stepForward() {
    let order = getStepOrder();
    if (activeStep < 0) {
        activeStep = order[0];
    } else {
        let currentIdx = order.indexOf(activeStep);
        if (currentIdx < order.length - 1) {
            activeStep = order[currentIdx + 1];
        } else {
            // Wrap around
            activeStep = order[0];
        }
    }
    // Auto-show info panel for active step
    selectedElement = activeStep;
    infoPanelVisible = true;
}

function resetAll() {
    activeStep = -1;
    selectedElement = -1;
    infoPanelVisible = false;
}

function windowResized() {
    updateCanvasSize();
    resizeCanvas(canvasWidth, canvasHeight);
    layoutElements();
}
