// Event Source Taxonomy MicroSim
// Hierarchical tree of event source types with expand/collapse and hover tooltips
// Uses built-in p5.js controls
// MicroSim template version 2026.02

let canvasWidth = 400;
let drawHeight = 500;
let controlHeight = 45;
let canvasHeight = drawHeight + controlHeight;
let margin = 25;
let defaultTextSize = 16;

// Tree data structure
let tree = {
  label: 'Employee Event Streams',
  color: '#333',
  expanded: true,
  tip: 'All digital footprints generated by employees using organizational tools',
  children: [
    {
      label: 'Communication',
      color: '#303F9F',
      expanded: true,
      tip: 'Events from messaging and scheduling tools',
      children: [
        {
          label: 'Email Events',
          color: '#303F9F',
          expanded: false,
          tip: 'SEND, RECEIVE, REPLY, FORWARD — rich metadata about communication networks',
          children: [
            { label: 'SEND', color: '#5C6BC0', tip: 'Outbound email dispatched to recipients' },
            { label: 'RECEIVE', color: '#5C6BC0', tip: 'Inbound email delivered to mailbox' },
            { label: 'REPLY', color: '#5C6BC0', tip: 'Response to an existing email thread' },
            { label: 'FORWARD', color: '#5C6BC0', tip: 'Email relayed to new recipients' }
          ]
        },
        {
          label: 'Chat Events',
          color: '#303F9F',
          expanded: false,
          tip: 'MESSAGE, REACTION, MENTION, THREAD_REPLY — fast-paced informal interactions',
          children: [
            { label: 'MESSAGE', color: '#5C6BC0', tip: 'Chat message posted to channel or DM' },
            { label: 'REACTION', color: '#5C6BC0', tip: 'Emoji reaction — lightweight engagement signal' },
            { label: 'MENTION', color: '#5C6BC0', tip: '@mention directing attention to a specific person' },
            { label: 'THREAD_REPLY', color: '#5C6BC0', tip: 'Reply within a specific message thread' }
          ]
        },
        {
          label: 'Calendar Events',
          color: '#303F9F',
          expanded: false,
          tip: 'MEETING_CREATE, ACCEPT, DECLINE, ATTEND — planned collaborative time',
          children: [
            { label: 'MEETING_CREATE', color: '#5C6BC0', tip: 'New meeting scheduled by organizer' },
            { label: 'ACCEPT', color: '#5C6BC0', tip: 'Attendee accepted the meeting invite' },
            { label: 'DECLINE', color: '#5C6BC0', tip: 'Attendee declined — a signal worth investigating' },
            { label: 'ATTEND', color: '#5C6BC0', tip: 'Actual participation in the meeting' }
          ]
        }
      ]
    },
    {
      label: 'Device & Application',
      color: '#D4880F',
      expanded: true,
      tip: 'Events from hardware and software usage',
      children: [
        {
          label: 'Desktop Activity',
          color: '#D4880F',
          expanded: false,
          tip: 'LOGIN, LOGOUT, APP_FOCUS, FILE_ACCESS — workstation usage patterns',
          children: [
            { label: 'LOGIN', color: '#E6A030', tip: 'User authenticated to workstation' },
            { label: 'LOGOUT', color: '#E6A030', tip: 'User session ended' },
            { label: 'APP_FOCUS', color: '#E6A030', tip: 'Application brought to foreground' },
            { label: 'FILE_ACCESS', color: '#E6A030', tip: 'Document opened, saved, or closed' }
          ]
        },
        {
          label: 'Mobile Events',
          color: '#D4880F',
          expanded: false,
          tip: 'APP_INSTALL, LOCATION, SYNC — mobile device management data',
          children: [
            { label: 'APP_INSTALL', color: '#E6A030', tip: 'Application installed on managed device' },
            { label: 'LOCATION', color: '#E6A030', tip: 'Location check-in for field workers (with consent)' },
            { label: 'SYNC', color: '#E6A030', tip: 'Email/calendar synchronization event' }
          ]
        },
        {
          label: 'Software Logs',
          color: '#D4880F',
          expanded: false,
          tip: 'RECORD_CREATE, APPROVAL, EXPORT — business application events',
          children: [
            { label: 'RECORD_CREATE', color: '#E6A030', tip: 'New record created in CRM/HR/PM system' },
            { label: 'APPROVAL', color: '#E6A030', tip: 'Workflow approval action completed' },
            { label: 'EXPORT', color: '#E6A030', tip: 'Data exported from application' }
          ]
        }
      ]
    },
    {
      label: 'Business Process',
      color: '#B8860B',
      expanded: true,
      tip: 'Events from structured workflows and compliance systems',
      children: [
        {
          label: 'Process Events',
          color: '#B8860B',
          expanded: false,
          tip: 'TASK_START, TASK_COMPLETE, HANDOFF, ESCALATION — workflow execution',
          children: [
            { label: 'TASK_START', color: '#DAA520', tip: 'Work item begins processing' },
            { label: 'TASK_COMPLETE', color: '#DAA520', tip: 'Work item finished successfully' },
            { label: 'HANDOFF', color: '#DAA520', tip: 'Work transferred to another person/team' },
            { label: 'ESCALATION', color: '#DAA520', tip: 'Issue escalated to higher authority' }
          ]
        },
        {
          label: 'Compliance Events',
          color: '#B8860B',
          expanded: false,
          tip: 'APPROVAL, REVIEW, AUDIT_LOG — regulatory and governance tracking',
          children: [
            { label: 'APPROVAL', color: '#DAA520', tip: 'Formal approval in compliance workflow' },
            { label: 'REVIEW', color: '#DAA520', tip: 'Compliance review completed' },
            { label: 'AUDIT_LOG', color: '#DAA520', tip: 'Action recorded for audit trail' }
          ]
        }
      ]
    }
  ]
};

// Rendering state
let nodePositions = []; // [{x, y, w, h, node, depth}]
let hoveredNode = null;
let expandAllBtn, collapseAllBtn;

function setup() {
  updateCanvasSize();
  const canvas = createCanvas(canvasWidth, canvasHeight);
  canvas.parent(document.querySelector('main'));

  expandAllBtn = createButton('Expand All');
  expandAllBtn.position(canvasWidth / 2 - 120, drawHeight + 8);
  expandAllBtn.mousePressed(() => setAllExpanded(tree, true));
  expandAllBtn.style('font-size', '13px');
  expandAllBtn.style('padding', '5px 14px');
  expandAllBtn.style('border-radius', '6px');
  expandAllBtn.style('cursor', 'pointer');
  expandAllBtn.style('background-color', '#303F9F');
  expandAllBtn.style('color', 'white');
  expandAllBtn.style('border', '1px solid #303F9F');

  collapseAllBtn = createButton('Collapse All');
  collapseAllBtn.position(canvasWidth / 2 + 10, drawHeight + 8);
  collapseAllBtn.mousePressed(() => setAllExpanded(tree, false));
  collapseAllBtn.style('font-size', '13px');
  collapseAllBtn.style('padding', '5px 14px');
  collapseAllBtn.style('border-radius', '6px');
  collapseAllBtn.style('cursor', 'pointer');
  collapseAllBtn.style('background-color', '#D4880F');
  collapseAllBtn.style('color', 'white');
  collapseAllBtn.style('border', '1px solid #D4880F');

  describe('Interactive hierarchical tree diagram showing the taxonomy of organizational event sources. Click branches to expand or collapse.', LABEL);
}

function setAllExpanded(node, state) {
  if (node.children) {
    node.expanded = state;
    for (let child of node.children) {
      setAllExpanded(child, state);
    }
  }
}

function draw() {
  updateCanvasSize();

  fill('aliceblue');
  stroke('silver');
  strokeWeight(1);
  rect(0, 0, canvasWidth, drawHeight);

  fill('white');
  stroke('silver');
  rect(0, drawHeight, canvasWidth, controlHeight);

  // Title
  noStroke();
  fill('black');
  textAlign(CENTER, TOP);
  textSize(20);
  text('Event Source Taxonomy', canvasWidth / 2, 8);

  // Render tree
  nodePositions = [];
  hoveredNode = null;
  let startX = canvasWidth / 2;
  let startY = 42;
  renderTree(tree, startX, startY, 0);

  // Draw tooltip
  if (hoveredNode) {
    drawTooltip(hoveredNode.tip, mouseX, mouseY);
  }
}

function renderTree(node, x, y, depth) {
  // Calculate node dimensions
  textSize(depth === 0 ? 14 : (depth === 1 ? 13 : 12));
  textStyle(BOLD);
  let labelW = textWidth(node.label) + 20;
  let nodeH = depth === 0 ? 28 : 24;
  let nodeW = max(labelW, 80);

  // Check hover
  let isHovered = mouseX > x - nodeW / 2 && mouseX < x + nodeW / 2 &&
                  mouseY > y && mouseY < y + nodeH;
  if (isHovered) hoveredNode = node;

  // Store position for click detection
  nodePositions.push({ x: x - nodeW / 2, y: y, w: nodeW, h: nodeH, node: node });

  // Draw node
  let bgColor = isHovered ? lerpColor(color(node.color), color(255), 0.7) : color(255);
  fill(bgColor);
  stroke(node.color);
  strokeWeight(2);
  rect(x - nodeW / 2, y, nodeW, nodeH, 6);

  // Draw expand indicator if has children
  if (node.children) {
    noStroke();
    fill(node.color);
    textSize(12);
    textStyle(NORMAL);
    textAlign(LEFT, CENTER);
    let indicator = node.expanded ? '[-]' : '[+]';
    text(indicator, x - nodeW / 2 + 4, y + nodeH / 2);
  }

  // Draw label
  noStroke();
  fill(node.color);
  textSize(depth === 0 ? 14 : (depth === 1 ? 13 : 12));
  textStyle(BOLD);
  textAlign(CENTER, CENTER);
  text(node.label, x, y + nodeH / 2);

  textStyle(NORMAL);

  // Draw children if expanded
  if (node.children && node.expanded) {
    let childCount = node.children.length;
    let totalWidth = canvasWidth - margin * 2;

    // Calculate spacing based on depth
    let childSpacing, childY;
    if (depth === 0) {
      // Top level: spread across full width
      childSpacing = totalWidth / childCount;
      childY = y + nodeH + 30;
    } else if (depth === 1) {
      // Second level: tighter spacing
      childSpacing = min(140, totalWidth / (childCount + 1));
      childY = y + nodeH + 28;
    } else {
      // Leaf level: stack vertically
      childSpacing = 0;
      childY = y + nodeH + 22;
    }

    for (let i = 0; i < childCount; i++) {
      let childX;
      if (depth >= 2) {
        // Stack vertically under parent
        childX = x;
        let cy = childY + i * 28;
        // Draw connecting line
        stroke(200);
        strokeWeight(1);
        line(x, y + nodeH, x, cy);
        renderTree(node.children[i], childX, cy, depth + 1);
      } else {
        // Spread horizontally
        let startOffset = -(childCount - 1) * childSpacing / 2;
        childX = x + startOffset + i * childSpacing;
        // Clamp to canvas
        childX = max(nodeW / 2 + margin, min(canvasWidth - nodeW / 2 - margin, childX));

        // Draw connecting line
        stroke(200);
        strokeWeight(1);
        let midY = y + nodeH + (childY - y - nodeH) / 2;
        line(x, y + nodeH, x, midY);
        line(x, midY, childX, midY);
        line(childX, midY, childX, childY);

        renderTree(node.children[i], childX, childY, depth + 1);
      }
    }
  }
}

function drawTooltip(tipText, mx, my) {
  textSize(12);
  textStyle(NORMAL);
  textAlign(LEFT, TOP);
  let tw = min(textWidth(tipText) + 16, canvasWidth - 20);
  let lines = wrapText(tipText, tw - 16);
  let th = lines.length * 16 + 12;

  let tx = mx + 12;
  let ty = my - th - 8;
  if (tx + tw > canvasWidth - 5) tx = canvasWidth - tw - 5;
  if (ty < 5) ty = my + 20;
  if (tx < 5) tx = 5;

  fill(50, 50, 50, 230);
  noStroke();
  rect(tx, ty, tw, th, 6);

  fill(255);
  textSize(12);
  for (let i = 0; i < lines.length; i++) {
    text(lines[i], tx + 8, ty + 6 + i * 16);
  }
}

function wrapText(txt, maxW) {
  let words = txt.split(' ');
  let lines = [];
  let currentLine = '';
  textSize(12);
  for (let w of words) {
    let testLine = currentLine.length === 0 ? w : currentLine + ' ' + w;
    if (textWidth(testLine) > maxW && currentLine.length > 0) {
      lines.push(currentLine);
      currentLine = w;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine.length > 0) lines.push(currentLine);
  return lines;
}

function mousePressed() {
  // Check if any node was clicked
  for (let pos of nodePositions) {
    if (mouseX > pos.x && mouseX < pos.x + pos.w &&
        mouseY > pos.y && mouseY < pos.y + pos.h) {
      if (pos.node.children) {
        pos.node.expanded = !pos.node.expanded;
      }
      break;
    }
  }
}

function windowResized() {
  updateCanvasSize();
  resizeCanvas(canvasWidth, canvasHeight);
  expandAllBtn.position(canvasWidth / 2 - 120, drawHeight + 8);
  collapseAllBtn.position(canvasWidth / 2 + 10, drawHeight + 8);
}

function updateCanvasSize() {
  const container = document.querySelector('main').getBoundingClientRect();
  canvasWidth = Math.floor(container.width);
}
